<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>
</head>
<body>
<h1 align="left">Chapter 13</h1>
 <h2 align="center">Realtime Events</h2>

<a name="RealtimeChapter">

<p>
</p><blockquote>I am Time, the destroyer of worlds.</blockquote>
<center>--Bhagavat Gita</center>

<p>
So far, the events which take place in a world have all been directly in
response to player input.  A world really comes alive with the addition of
events that are generated by the world itself.  That is the subject of this
chapter.
</p><p>
Normally code is executed as fast as the computer can process it.  When the
instructions are instead scheduled according to the passage of time, this is
known as <em>realtime</em> execution.  Events generated by the world are
usually done in realtime, or they would all take place within a moment after
starting up and would be of little interest to the players.
</p></a><p><a name="RealtimeChapter">
</a><a name="13.1">
</a></p>
<h3><a name="13.1">1. <var>sleep</var> instruction</a></h3>
<a name="13.1">

<p>
Generally speaking, realtime execution is a matter of postponing the
execution of code for a certain amount of time.  DM provides the
<var>sleep</var> instruction for doing precisely that.  It causes execution in
the current procedure to halt for the specified amount of time.
</p><p>
</p><table align="center" border="1"><tbody><tr><td>
<table border="0">
<tbody><tr><td>
<var>sleep</var> </td>
<td> (Delay) </td>
</tr>
<tr><td>
               </td>
<td> <code>Delay</code> is the amount of time to wait in 10$^th$s of seconds
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>

<p></p><p>
A multi-user environment such as a BYOND world cannot waste any amount of
time; it must always be ready to respond to input.  It is important,
therefore, to realize that <var>sleep</var> only halts the current procedure
and its callers.  While one procedure is sleeping, others may still operate
normally.
</p><p>
There are several other "sleeping" instructions in DM, each with its own
purpose.  <small>(In fact you have already seen one such
instruction--namely <var>prompt</var>.  It causes the current procedure to
sleep until the player finishes entering input.)</small>   They all share the behavior
of causing the current procedure and its callers to halt temporarily and
resume execution at a later time.
</p><p>
The following example uses <var>sleep</var> to time the motion of the heavens.
</p><p>

</p><pre>proc/Weather()
   for()
      world &lt;&lt; "The sun rises in the east."
      sleep(500)
      world &lt;&lt; "The noon day sun rises high in the sky."
      sleep(500)
      world &lt;&lt; "The sun sinks low in the west."
      sleep(1000)
</pre>
<p>
A <var>for</var> statement without any parameters as used here is one way of
creating an infinite loop.  If the body of such a loop never slept, it would
cause the world to grind to a halt, ignoring further player input.
  <small>(As a precaution, however, code such as an infinite loop which
continues for too long is aborted to prevent the entire world from getting
locked up.)</small>   By sleeping inside the loop, however, the desired effect is
achieved: a periodic message about the time of day is broadcast to everyone
in the world.
</p></a><p><a name="13.1">
</a><a name="13.2">
</a></p>
<h3><a name="13.2">2. <var>spawn</var> statement</a></h3>
<a name="13.2">

<p>
The <var>spawn</var> statement is similar to <var>sleep</var> except instead of
delaying the entire procedure, it only postpones the following statement or
block of statements.  Execution simply skips around the "spawned" code and
only comes back later when the specified amount of time has passed.
</p><p>
</p><table align="center" border="1"><tbody><tr><td>
<table border="0">
<tbody><tr><td>
<var>spawn</var> </td>
<td> (Delay) Statement </td>
</tr>
<tr><td>
               </td>
<td> <code>Delay</code> is the postponement time in 10$^th$s of seconds.
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>

<p></p><p>
The choice of whether to use <var>sleep</var> or <var>spawn</var> is mostly a
matter of convenience.  In many cases either one can be used to accomplish
the same thing.  The structure of the code generally determines which one is
more convenient.  If you wish to do additional processing after the delayed
code, <var>spawn</var> is the best choice.
</p><p>
The following example uses <var>spawn</var> to sanitize a room.
</p><p>

</p><pre>area/sickroom
   //how long to wait before clean cycle
   var/const/alarm = 100

   //moment when countdown started
   var/start_time = 0

   Enter(var/mob/entrant)
      if(!start_time)
         start_time = world.time
         spawn(alarm)
            for(entrant in src)
               entrant &lt;&lt; "The disinfectant hits you.  Aaahhhh!"
               del entrant
            start_time = 0 //ready for another round

      var/time_left = (alarm - (world.time - start_time))/10
      entrant &lt;&lt; "In [time_left] second\s this room will be disinfected."
      entrant &lt;&lt; "Have a nice day!"
      return 1
</pre>
<p>
The first time someone steps into the room, the trigger is set and the
deadly code is spawned.  The <var>Enter</var> proc continues to inform each
person who comes how much time is left.  When the moment comes, the dirty
business is done inside the spawned block of code.  Note that when the
spawned code is executed, it automatically halts at the end of the block, as
though it were an entirely separate procedure.
</p></a><p><a name="13.2">
</a><a name="13.3">
</a></p>
<h3><a name="13.3">3. Timing Specifics</a></h3>
<a name="13.3">
<p>
When making heavy use of realtime execution, it is helpful to know how it
all happens inside.  This section describes the gears and springs that make
the world tick.
</p></a><p><a name="13.3">
</a><a name="13.3.1">
</a></p>
<h4><a name="13.3.1">3.1 Threads of Execution</a></h4>
<a name="13.3.1">

<p>
A DM world is <em>single-threaded</em>. That means only one
piece of code is being executed at a time.  If this were not true, you would
have to worry a lot more about potential problems in your code.  For
example, if a spawned block of code like the one in the previous example
deletes objects from the world, it could cause trouble if code elsewhere
were simultaneously using those objects.  If the code attempted to access
variables or procedures of deleted objects, it would crash, possibly leaving
some important operation half finished.
</p><p>
  <small>(
If you want parallelism, however, you can still split a world across
multiple servers.  If you have multiple CPUs in one machine or multiple
machines, you will have created parallel universes!
)</small>  
</p><p>
Since there is only a single uninterrupted thread of execution, however, you
can be much more confident when writing code.  Between one statement and the
next, <em>nothing</em> happens.  If an object exists at the end of one
statement, it will still exist at the beginning of the next.
</p><p>
The only exception to this rule is, of course, instructions which sleep.  In
that case, you should assume that anything could have happened during the
pause.  A variable that referred to an object could have become null because
the object was deleted.  Before trusting it, you should check to make sure
that hasn't happened.
</p><p>
The <var>src</var> variable is handled specially in this respect.  When the
<var>src</var> of a sleeping procedure is deleted, the procedure is canceled.
That is almost always the desired effect so it saves you the trouble of
explicitly checking for this case.  When you don't want this to happen, you
can always set the <var>src</var> variable to null before sleeping.  That makes
the procedure independent of the existence of the <var>src</var> object.
</p></a><p><a name="13.3.1">
</a><a name="13.3.2">
</a></p>
<h4><a name="13.3.2">3.2 Clock Ticks</a></h4>
<a name="13.3.2">

<p>
The server breaks time into segments called <em>ticks</em>.  At each tick of
the server's clock, any sleeping procedures that are scheduled to happen are
called.  If several procedures are waiting, they are called one after the
other in the same order they went to sleep.
</p><p>
Normally, the server finishes processing all the waiting procedures with
time to spare before the end of the tick.  During the remaining time, it
handles any input, or if there is none it simply idles.  If there are
procedures that take a long time to finish, it is possible for the server to
go into overtime.  In that case the tick will take longer to finish than it
was supposed to and player input may get back-logged.
</p><p>
This situation is called <em>server lag</em>.  It is similar, from the player's
point of view, to <em>network lag</em>, but in that case the backlog may go
both ways--either input or output may get delayed during transmission.  To
tell which kind of lag you are having, you can check the <var>world.cpu</var>
variable.  This tells you what percentage of the tick is being used up.  If
it is close to 100 or above, your server is lagging.
</p><p>
Obviously, getting a faster computer and writing more efficient procedures are
two ways to decrease server lag.  Another way is to give in and increase the
length of a tick.  That can be done by changing <var>world.tick_lag</var>.  The
longer the length of a tick, the less overhead (i.e. extra processing)
involved in running the world.  Clients are also limited to sending one
command per tick, so increasing the length of the tick also helps reduce
input backlog.  Of course that comes at the cost of slowing the client
down, but that is better than having the server get further and further
behind.
</p><p>
All timings in the game are rounded to the nearest tick.  That means if you
require very quick timings, you will need to decrease <var>world.tick_lag</var>
to an acceptable level.  By default it is 1, which means the server ticks 10
times per second.  By decreasing it, you also quicken the pace at which
players can move and act.  However, the cost of doing so is a greater burden
on the server and the network, either of which may cause lag.
</p></a><p><a name="13.3.2">
</a><a name="13.3.3">
</a></p>
<h4><a name="13.3.3">3.3 Sequencing Actions</a></h4>
<a name="13.3.3">
<p>
As a related note on this subject, both <var>sleep</var> and <var>spawn</var> may
be used without an argument.  In that case, the delay is as short as
possible (i.e. just one tick).  The same is true if a time is specified that
is less than the length of a tick.  Sometimes this feature is used when the
delay is intended merely to control the order in which things happen.
</p><p>
For example, suppose you wanted to display a message when mobs exit a room.
You might not want the mob and any others who are exiting during the same
tick to see the message.  The trouble is you don't know who else might be
about to exit.  In that case, you can simply delay the notice for an
instant.  That gives everyone else a chance to exit the room before the
notice is displayed to the remaining occupants.
</p><p>

</p><pre>area/room
   Exit()
      . = ..()
      if(. &amp;&amp; usr) spawn src &lt;&lt; "[usr] leaves."
</pre>
<p>
Notice how this example sets the return value by assigning <var>.</var> to the
result of the parent procedure.  That ensures that the exit operation is
indeed allowed to proceed.  Otherwise, a <var>null</var> return value blocks
the player from leaving.
</p><p>
Also notice how we checked to see if <var>usr</var> is non-<var>null</var>.
Otherwise, the message would be generated, not only for mobs, but for objs
leaving the room too.
</p></a><p><a name="13.3.3">
</a><a name="13.3.4">
</a></p>
<h4><a name="13.3.4">3.4 The Sleepless Server</a></h4>
<a name="13.3.4">
<p>
A final point should be mentioned or you may run into trouble.  Sleeping
operations cause the current procedure, its caller, its caller's caller, and
so forth to freeze for some length of time.  As you have seen, you can use
<var>spawn()</var> to avoid waiting for a sleeping operation.
</p><p>
As it happens, that is very similar to what the server does when it calls a
procedure.  Procedures called by the server include the various built-in
ones like <var>Enter</var>, <var>Exit</var>, and <var>Login</var>.  If you sleep
inside one of those procedures, execution of the server will immediately
resume as though you had returned from your procedure.  Do not, therefore,
expect the action of the server (like moving an object) to be delayed as a
result.

</p></a>
</body>
</html>